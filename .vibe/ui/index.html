<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>VIBE Pipeline Monitor</title>
<style>
  :root {
    --bg:      #0d0d14;
    --surface: #14141f;
    --border:  #1e1e2e;
    --text:    #e0e0e8;
    --dim:     #6b6b80;
    --blue:    #4a9eff;
    --green:   #34d399;
    --red:     #f87171;
    --amber:   #fbbf24;
    --grey:    #3a3a4a;
    --edge:    #2a2a3a;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    font-family: 'SF Mono', 'Cascadia Code', 'Fira Code', monospace;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  #header {
    padding: 14px 24px;
    background: var(--surface);
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 20px;
    flex-shrink: 0;
  }
  #header h1 {
    font-size: 16px;
    font-weight: 700;
    letter-spacing: 3px;
    color: var(--blue);
  }
  #goal-text {
    font-size: 14px;
    color: var(--dim);
    flex: 1;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #status-badge {
    font-size: 12px;
    padding: 3px 12px;
    border-radius: 3px;
    font-weight: 700;
    letter-spacing: 1px;
    text-transform: uppercase;
    background: var(--grey);
    color: #e0e0e8;
  }
  #main-area {
    flex: 1;
    display: flex;
    overflow: hidden;
  }
  #canvas-wrapper {
    flex: 1;
    overflow: hidden;
    position: relative;
    background-color: var(--bg);
    background-image: radial-gradient(circle, #1e1e2e 1px, transparent 1px);
    background-size: 24px 24px;
  }
  #canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 1500px;
    height: 620px;
    transform-origin: top left;
  }
  #edges-svg {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    overflow: visible;
  }
  .node {
    position: absolute;
    width: 168px;
    height: 76px;
    background: var(--surface);
    border: 1.5px solid var(--border);
    border-radius: 8px;
    padding: 10px 12px;
    cursor: pointer;
    transition: border-color 0.15s, box-shadow 0.15s, opacity 0.15s;
    user-select: none;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
  }
  .node:hover { border-color: #4a4a6a; }
  .node.pending { opacity: 0.4; }
  .node.running {
    border-color: var(--blue);
    box-shadow: 0 0 16px rgba(74,158,255,0.22);
  }
  .node.passed { border-color: var(--green); }
  .node.failed { border-color: var(--red); }
  .node.skipped { opacity: 0.25; }
  .node.waiting_user { border-color: var(--amber); }
  .node-top {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .node-phase {
    font-size: 11px;
    color: var(--dim);
    background: var(--bg);
    padding: 1px 5px;
    border-radius: 3px;
    flex-shrink: 0;
  }
  .node-name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    flex: 1;
  }
  .node-warn {
    font-size: 12px;
    color: var(--amber);
    flex-shrink: 0;
  }
  .node-bottom {
    display: flex;
    align-items: center;
    gap: 5px;
  }
  .node-icon {
    font-size: 14px;
    width: 16px;
    text-align: center;
    flex-shrink: 0;
  }
  .node-status-text { font-size: 11px; color: var(--dim); }
  .node-activity {
    font-size: 11px;
    color: var(--blue);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  @keyframes pulse {
    0%,100% { opacity: 1; }
    50%      { opacity: 0.35; }
  }
  .node.running .node-icon { animation: pulse 1.2s ease-in-out infinite; }
  .node-selected { outline: 2px solid var(--blue) !important; outline-offset: 2px; }

  #detail-panel {
    width: 360px;
    background: var(--surface);
    border-left: 1px solid var(--border);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    overflow: hidden;
  }
  #agent-detail-scroll {
    flex: 0 0 auto;
    padding: 20px;
    overflow-y: auto;
    max-height: 55%;
    border-bottom: 1px solid var(--border);
  }
  #log-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    min-height: 0;
  }
  #log-panel-header {
    padding: 11px 20px;
    font-size: 11px;
    color: var(--dim);
    letter-spacing: 2px;
    text-transform: uppercase;
    font-weight: 700;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #log-count {
    font-size: 11px;
    color: var(--dim);
    font-weight: 400;
    letter-spacing: 0;
  }
  #log-entries {
    flex: 1;
    overflow-y: auto;
    padding: 4px 0;
    min-height: 0;
  }
  .log-entry {
    padding: 7px 20px;
    border-bottom: 1px solid var(--border);
    cursor: default;
  }
  .log-entry:last-child { border-bottom: none; }
  .log-entry-header {
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 3px;
  }
  .log-agent {
    font-size: 11px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--blue);
    flex-shrink: 0;
  }
  .log-time {
    font-size: 11px;
    color: var(--dim);
    flex-shrink: 0;
  }
  .log-artifact {
    font-size: 11px;
    color: var(--green);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .log-decision {
    font-size: 12px;
    color: var(--text);
    line-height: 1.35;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .dp-title {
    font-size: 11px;
    color: var(--blue);
    letter-spacing: 2px;
    text-transform: uppercase;
    font-weight: 700;
    margin-bottom: 18px;
  }
  .dp-hint { font-size: 13px; color: var(--dim); }
  .dp-field { margin-bottom: 14px; }
  .dp-label {
    font-size: 11px;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    display: block;
    margin-bottom: 3px;
  }
  .dp-value { font-size: 15px; color: var(--text); line-height: 1.4; }

  #summary-bar {
    padding: 10px 24px;
    background: var(--surface);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    gap: 28px;
    font-size: 14px;
    color: var(--dim);
    flex-shrink: 0;
  }
  .metric { display: flex; align-items: center; gap: 7px; }
  .metric-val { color: var(--text); font-weight: 600; }
  .gates-row { display: flex; gap: 6px; align-items: center; }
  .gate-pill {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    font-size: 11px;
    padding: 3px 8px;
    border-radius: 10px;
    background: var(--bg);
    border: 1px solid var(--border);
    color: var(--dim);
  }
  .gdot {
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--grey);
    flex-shrink: 0;
  }
  .gdot.passed { background: var(--green); }
  .gdot.failed { background: var(--red); }
</style>
</head>
<body>

<div id="header">
  <h1>VIBE</h1>
  <span id="goal-text">Waiting for pipeline...</span>
  <span id="status-badge">—</span>
</div>

<div id="main-area">
  <div id="canvas-wrapper">
    <div id="canvas">
      <svg id="edges-svg" xmlns="http://www.w3.org/2000/svg"></svg>
    </div>
  </div>
  <div id="detail-panel">
    <div id="agent-detail-scroll"></div>
    <div id="log-panel">
      <div id="log-panel-header">
        Activity Log
        <span id="log-count"></span>
      </div>
      <div id="log-entries"></div>
    </div>
  </div>
</div>

<div id="summary-bar"></div>

<script>
'use strict';

// ── Constants ─────────────────────────────────────────────────────────────────

const NW = 168, NH = 76;
const SVG_NS = 'http://www.w3.org/2000/svg';

const AGENTS = [
  { id: 'research',           label: 'Research',        phase: '1'   },
  { id: 'analyst',            label: 'Analyst',         phase: '2'   },
  { id: 'architect',          label: 'Architect',       phase: '3'   },
  { id: 'security_planner',   label: 'Sec. Planner',    phase: '4'   },
  { id: 'ux_designer',        label: 'UX Designer',     phase: '5'   },
  { id: 'implementer',        label: 'Implementer',     phase: '6'   },
  { id: 'test_writer',        label: 'Test Writer',     phase: '7'   },
  { id: 'critic',             label: 'Critic',          phase: '8'   },
  { id: 'fixer',              label: 'Fixer',           phase: '9'   },
  { id: 'security_auditor',   label: 'Sec. Auditor',    phase: '10'  },
  { id: 'performance_agent',  label: 'Performance',     phase: '10b' },
  { id: 'completeness_judge', label: 'Judge',           phase: '11'  },
  { id: 'documenter',         label: 'Documenter',      phase: '12'  },
  { id: 'deployer',           label: 'Deployer',        phase: '13'  },
];

// Node top-left positions — two-row layout (1500×620 logical canvas)
const POS = {
  // Row 1: phases 1–7 (y=50, step=200, node 168px wide → 32px gap)
  research:           { x: 80,   y: 50  },
  analyst:            { x: 280,  y: 50  },
  architect:          { x: 480,  y: 50  },
  security_planner:   { x: 680,  y: 50  },
  ux_designer:        { x: 880,  y: 50  },
  implementer:        { x: 1080, y: 50  },
  test_writer:        { x: 1280, y: 50  },
  // Row 2: phases 8–13 (y=340)
  critic:             { x: 240,  y: 340 },
  fixer:              { x: 240,  y: 490 },
  security_auditor:   { x: 490,  y: 250 },
  performance_agent:  { x: 490,  y: 410 },
  completeness_judge: { x: 740,  y: 340 },
  documenter:         { x: 940,  y: 340 },
  deployer:           { x: 1140, y: 340 },
};

const STATUS_ICON = {
  pending:      '\u25CB',
  running:      '\u25CF',
  passed:       '\u2713',
  failed:       '\u2717',
  skipped:      '\u2014',
  waiting_user: '\u23F8',
};

const STATUS_COLOR = {
  pending:      'var(--dim)',
  running:      'var(--blue)',
  passed:       'var(--green)',
  failed:       'var(--red)',
  skipped:      'var(--dim)',
  waiting_user: 'var(--amber)',
};

const GATE_LABELS = {
  prd_coverage:  'PRD',
  test_coverage: 'Tests',
  critic_score:  'Critic',
  security:      'Sec',
  performance:   'Perf',
};

// ── State ─────────────────────────────────────────────────────────────────────

let pipelineState = null;
let selectedId    = null;
let nodeRefs      = {};  // agentId → { node, icon, statusTxt, activityEl, warnEl }
let dpRefs        = null;
let summaryRefs   = null;

// ── DOM helpers ───────────────────────────────────────────────────────────────

function mk(tag, cls) {
  const e = document.createElement(tag);
  if (cls) e.className = cls;
  return e;
}

function svgEl(tag) {
  return document.createElementNS(SVG_NS, tag);
}

function setText(el, s) {
  el.textContent = String(s == null ? '' : s);
}

// ── Edge path helpers ─────────────────────────────────────────────────────────

function pt(id, side) {
  const p = POS[id];
  switch (side) {
    case 'r': return { x: p.x + NW,      y: p.y + NH / 2 };
    case 'l': return { x: p.x,           y: p.y + NH / 2 };
    case 'b': return { x: p.x + NW / 2,  y: p.y + NH     };
    case 't': return { x: p.x + NW / 2,  y: p.y          };
    default:  return { x: p.x,           y: p.y           };
  }
}

function hPath(s, t) {
  const dx = Math.abs(t.x - s.x);
  const off = Math.max(36, dx * 0.35);
  return `M${s.x},${s.y} C${s.x + off},${s.y} ${t.x - off},${t.y} ${t.x},${t.y}`;
}

function vPath(s, t) {
  const dy = Math.abs(t.y - s.y);
  const off = Math.max(28, dy * 0.4);
  return `M${s.x},${s.y} C${s.x},${s.y + off} ${t.x},${t.y - off} ${t.x},${t.y}`;
}

// ── Edge definitions ──────────────────────────────────────────────────────────

const EDGES = [
  // Row 1 — linear pipeline (phases 1–7)
  { id: 'res-ana', d: hPath(pt('research',        'r'), pt('analyst',          'l')) },
  { id: 'ana-arc', d: hPath(pt('analyst',         'r'), pt('architect',        'l')) },
  { id: 'arc-sp',  d: hPath(pt('architect',       'r'), pt('security_planner', 'l')) },
  { id: 'sp-ux',   d: hPath(pt('security_planner','r'), pt('ux_designer',      'l')) },
  { id: 'ux-imp',  d: hPath(pt('ux_designer',     'r'), pt('implementer',      'l')) },
  { id: 'imp-tw',  d: hPath(pt('implementer',     'r'), pt('test_writer',      'l')) },

  // Row 1 → Row 2: test_writer bottom → critic top (S-curve)
  {
    id: 'tw-cri',
    d: (function () {
      const s = pt('test_writer', 'b');
      const t = pt('critic', 't');
      const midY = Math.round((s.y + t.y) / 2);
      return `M${s.x},${s.y} C${s.x},${midY} ${t.x},${midY} ${t.x},${t.y}`;
    }()),
  },

  // Critic → Fixer (downward)
  {
    id: 'cri-fix',
    d: vPath(pt('critic', 'b'), pt('fixer', 't')),
    stroke: 'var(--amber)',
  },

  // Fixer → Critic (back-edge, curves left — the loop)
  {
    id: 'fix-cri',
    d: (function () {
      const s = pt('fixer',  'l');
      const t = pt('critic', 'l');
      const off = 70;
      return `M${s.x},${s.y} C${s.x - off},${s.y} ${t.x - off},${t.y} ${t.x},${t.y}`;
    }()),
    stroke: 'var(--amber)',
    dash: true,
  },

  // Critic → parallel agents (phases 10 + 10b)
  { id: 'cri-sa', d: hPath(pt('critic', 'r'), pt('security_auditor',  'l')) },
  { id: 'cri-pa', d: hPath(pt('critic', 'r'), pt('performance_agent', 'l')) },

  // Parallel → completeness_judge
  { id: 'sa-cj', d: hPath(pt('security_auditor',  'r'), pt('completeness_judge', 'l')) },
  { id: 'pa-cj', d: hPath(pt('performance_agent', 'r'), pt('completeness_judge', 'l')) },

  // Judge → Documenter → Deployer
  { id: 'cj-doc',  d: hPath(pt('completeness_judge', 'r'), pt('documenter', 'l')) },
  { id: 'doc-dep', d: hPath(pt('documenter',          'r'), pt('deployer',   'l')) },
];

// ── Build SVG edges ───────────────────────────────────────────────────────────

function buildEdges() {
  const svg = document.getElementById('edges-svg');

  const defs = svgEl('defs');

  function addMarker(id, color) {
    const m = svgEl('marker');
    m.setAttribute('id', id);
    m.setAttribute('markerWidth',  '8');
    m.setAttribute('markerHeight', '8');
    m.setAttribute('refX', '7');
    m.setAttribute('refY', '3');
    m.setAttribute('orient', 'auto');
    const p = svgEl('path');
    p.setAttribute('d', 'M0,0 L0,6 L8,3 z');
    p.setAttribute('fill', color);
    m.appendChild(p);
    defs.appendChild(m);
  }

  addMarker('arr-grey',  'var(--edge)');
  addMarker('arr-amber', 'var(--amber)');
  svg.appendChild(defs);

  for (const edge of EDGES) {
    const path = svgEl('path');
    path.setAttribute('d', edge.d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', edge.stroke || 'var(--edge)');
    path.setAttribute('stroke-width', '1.5');
    if (edge.dash) path.setAttribute('stroke-dasharray', '5,4');
    path.setAttribute('marker-end', edge.stroke ? 'url(#arr-amber)' : 'url(#arr-grey)');
    svg.appendChild(path);
  }
}

// ── Build nodes ───────────────────────────────────────────────────────────────

function buildNodes() {
  const canvas = document.getElementById('canvas');

  for (const agent of AGENTS) {
    const pos = POS[agent.id];
    if (!pos) continue;

    const node = mk('div', 'node pending');
    node.style.left = pos.x + 'px';
    node.style.top  = pos.y + 'px';

    // Top row: phase badge + name + warn badge
    const top = mk('div', 'node-top');
    const phase = mk('span', 'node-phase');
    setText(phase, agent.phase);
    const name = mk('span', 'node-name');
    setText(name, agent.label);
    const warn = mk('span', 'node-warn');
    setText(warn, '\u26A0');
    warn.style.display = 'none';
    warn.title = 'Input tokens exceeded 8,000 threshold';
    top.appendChild(phase);
    top.appendChild(name);
    top.appendChild(warn);

    // Bottom row: status icon + status text OR activity text
    const bottom = mk('div', 'node-bottom');
    const icon = mk('span', 'node-icon');
    setText(icon, STATUS_ICON.pending);
    icon.style.color = STATUS_COLOR.pending;
    const statusTxt = mk('span', 'node-status-text');
    setText(statusTxt, 'pending');
    const activityEl = mk('span', 'node-activity');
    activityEl.style.display = 'none';
    bottom.appendChild(icon);
    bottom.appendChild(statusTxt);
    bottom.appendChild(activityEl);

    node.appendChild(top);
    node.appendChild(bottom);

    node.addEventListener('click', () => selectAgent(agent.id));
    canvas.appendChild(node);

    nodeRefs[agent.id] = { node, icon, statusTxt, activityEl, warn };
  }
}

// ── Build detail panel ────────────────────────────────────────────────────────

function buildDetailPanel() {
  const panel = document.getElementById('agent-detail-scroll');

  const title = mk('div', 'dp-title');
  setText(title, 'Agent Detail');
  panel.appendChild(title);

  const hint = mk('div', 'dp-hint');
  setText(hint, 'Click a node to inspect');
  panel.appendChild(hint);

  const fieldDefs = [
    { key: 'name',      label: 'Name'           },
    { key: 'phase',     label: 'Phase'          },
    { key: 'status',    label: 'Status'         },
    { key: 'activity',  label: 'Activity'       },
    { key: 'tokensIn',  label: 'Tokens In'      },
    { key: 'tokensOut', label: 'Tokens Out'     },
    { key: 'warnMsg',   label: '\u26A0 Warning' },
  ];

  const fields = {};
  for (const { key, label } of fieldDefs) {
    const field = mk('div', 'dp-field');
    field.style.display = 'none';
    const lbl = mk('span', 'dp-label');
    setText(lbl, label);
    const val = mk('div', 'dp-value');
    field.appendChild(lbl);
    field.appendChild(val);
    panel.appendChild(field);
    fields[key] = { field, val };
  }

  return { hint, fields };
}

// ── Build summary bar ─────────────────────────────────────────────────────────

function buildSummaryBar() {
  const bar = document.getElementById('summary-bar');

  function addMetric(labelStr) {
    const m = mk('div', 'metric');
    const lbl = mk('span');
    setText(lbl, labelStr);
    const val = mk('span', 'metric-val');
    m.appendChild(lbl);
    m.appendChild(val);
    bar.appendChild(m);
    return val;
  }

  const tokensVal  = addMetric('Tokens:');
  const elapsedVal = addMetric('Elapsed:');
  const phasesVal  = addMetric('Phases:');

  const gatesMetric = mk('div', 'metric');
  const gatesLbl = mk('span');
  setText(gatesLbl, 'Gates:');
  const gatesRow = mk('div', 'gates-row');
  gatesMetric.appendChild(gatesLbl);
  gatesMetric.appendChild(gatesRow);
  bar.appendChild(gatesMetric);

  return { tokensVal, elapsedVal, phasesVal, gatesRow };
}

// ── Update helpers ────────────────────────────────────────────────────────────

function fmtTokens(n) {
  if (n == null) return '—';
  if (n === 0) return '0';
  return n >= 1000 ? (n / 1000).toFixed(1) + 'k' : String(n);
}

function fmtTime(iso) {
  if (!iso) return '';
  const d = new Date(iso);
  return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
}

function fmtElapsed(startedAt) {
  if (!startedAt) return '--:--';
  const secs = Math.floor((Date.now() - new Date(startedAt).getTime()) / 1000);
  const m = Math.floor(secs / 60);
  const s = String(secs % 60).padStart(2, '0');
  return `${m}:${s}`;
}

// ── Select agent ──────────────────────────────────────────────────────────────

function selectAgent(id) {
  // Clear previous selection outline
  if (selectedId && nodeRefs[selectedId]) {
    nodeRefs[selectedId].node.classList.remove('node-selected');
  }
  selectedId = id;
  if (nodeRefs[id]) {
    nodeRefs[id].node.classList.add('node-selected');
  }
  renderDetailPanel();
}

// ── Render functions ──────────────────────────────────────────────────────────

function renderNodes(agents) {
  for (const agent of AGENTS) {
    const refs = nodeRefs[agent.id];
    if (!refs) continue;
    const s = (agents || {})[agent.id] || {};
    const status = s.status || 'pending';

    refs.node.className = 'node ' + status + (selectedId === agent.id ? ' node-selected' : '');

    setText(refs.icon, STATUS_ICON[status] || STATUS_ICON.pending);
    refs.icon.style.color = STATUS_COLOR[status] || STATUS_COLOR.pending;

    if (s.activity) {
      refs.statusTxt.style.display = 'none';
      refs.activityEl.style.display = '';
      setText(refs.activityEl, s.activity);
    } else {
      refs.activityEl.style.display = 'none';
      refs.statusTxt.style.display = '';
      setText(refs.statusTxt, status);
    }

    refs.warn.style.display = (s.tokens_in || 0) > 8000 ? '' : 'none';
  }
}

function renderLogFeed(entries) {
  const container = document.getElementById('log-entries');
  const countEl   = document.getElementById('log-count');
  if (!container) return;

  const count = entries.length;
  setText(countEl, count ? `(${count})` : '');

  // Re-render only if entry count changed — avoids scroll jump during ticker
  if (container.dataset.count === String(count)) return;
  container.dataset.count = String(count);

  while (container.firstChild) container.removeChild(container.firstChild);

  for (const entry of entries) {
    const row = mk('div', 'log-entry');

    const hdr = mk('div', 'log-entry-header');

    const agentEl = mk('span', 'log-agent');
    setText(agentEl, (entry.agent || '?').replace('_', ' '));
    hdr.appendChild(agentEl);

    const timeEl = mk('span', 'log-time');
    setText(timeEl, fmtTime(entry.timestamp));
    hdr.appendChild(timeEl);

    if (entry.artifact_written) {
      const art = mk('span', 'log-artifact');
      setText(art, '→ ' + entry.artifact_written.split('/').pop());
      hdr.appendChild(art);
    }

    row.appendChild(hdr);

    if (entry.decision) {
      const dec = mk('div', 'log-decision');
      setText(dec, entry.decision);
      row.appendChild(dec);
    }

    container.appendChild(row);
  }

  // Auto-scroll to bottom (newest entry)
  container.scrollTop = container.scrollHeight;
}

function renderDetailPanel() {
  if (!dpRefs) return;
  const { hint, fields } = dpRefs;

  function show(key, valueStr, color) {
    const f = fields[key];
    if (!f) return;
    f.field.style.display = '';
    setText(f.val, valueStr);
    f.val.style.color = color || 'var(--text)';
  }
  function hide(key) {
    const f = fields[key];
    if (f) f.field.style.display = 'none';
  }

  if (!selectedId) {
    hint.style.display = '';
    for (const f of Object.values(fields)) f.field.style.display = 'none';
    return;
  }

  hint.style.display = 'none';
  const agent = AGENTS.find(a => a.id === selectedId);
  const s = (pipelineState && pipelineState.agents && pipelineState.agents[selectedId]) || {};
  const status = s.status || 'pending';

  show('name',     agent ? agent.label : selectedId);
  show('phase',    agent ? String(agent.phase) : '');
  show('status',   STATUS_ICON[status] + ' ' + status, STATUS_COLOR[status] || 'var(--text)');

  if (s.activity) show('activity', s.activity);
  else            hide('activity');

  show('tokensIn',  fmtTokens(s.tokens_in));
  show('tokensOut', fmtTokens(s.tokens_out));

  if ((s.tokens_in || 0) > 8000) {
    show('warnMsg', 'Input exceeded 8,000 token threshold', 'var(--amber)');
  } else {
    hide('warnMsg');
  }
}

function renderHeader(state) {
  const goalEl = document.getElementById('goal-text');
  const badge  = document.getElementById('status-badge');
  setText(goalEl, state && state.goal ? state.goal : 'Initialising...');
  const st = (state && state.status) || 'unknown';
  setText(badge, st);
  const bgMap = { complete: '#34d399', running: '#4a9eff', failed: '#f87171', interrupted: '#fbbf24', escalated: '#f87171', initialising: '#3a3a4a' };
  badge.style.background = bgMap[st] || '#3a3a4a';
  badge.style.color = (st === 'initialising' || st === 'unknown') ? 'var(--dim)' : '#050508';
}

function renderSummaryBar(state) {
  if (!summaryRefs) return;
  const { tokensVal, elapsedVal, phasesVal, gatesRow } = summaryRefs;

  const ti = (state && state.token_totals && state.token_totals.in)  || 0;
  const to = (state && state.token_totals && state.token_totals.out) || 0;
  setText(tokensVal, fmtTokens(ti) + ' in / ' + fmtTokens(to) + ' out');
  setText(elapsedVal, fmtElapsed(state && state.started_at));

  const agents = (state && state.agents) || {};
  const done  = Object.values(agents).filter(a => a.status === 'passed' || a.status === 'skipped').length;
  setText(phasesVal, done + '/' + AGENTS.length);

  // Gates — rebuild pills
  while (gatesRow.firstChild) gatesRow.removeChild(gatesRow.firstChild);
  const gates = (state && state.gates) || {};
  for (const [key, val] of Object.entries(gates)) {
    const pill = mk('div', 'gate-pill');
    const dot  = mk('span', 'gdot' + (val === null ? '' : val ? ' passed' : ' failed'));
    const lbl  = mk('span');
    setText(lbl, GATE_LABELS[key] || key);
    pill.title = key + ': ' + (val === null ? 'pending' : val ? 'passed' : 'failed');
    pill.appendChild(dot);
    pill.appendChild(lbl);
    gatesRow.appendChild(pill);
  }
}

// ── Main update (called on every SSE event) ───────────────────────────────────

function onUpdate(payload) {
  pipelineState = payload.state;
  if (!pipelineState) return;

  renderHeader(pipelineState);
  renderNodes(pipelineState.agents);
  renderDetailPanel();
  renderSummaryBar(pipelineState);
  renderLogFeed(payload.log || []);

  // Auto-select the running agent if nothing is selected
  if (!selectedId) {
    const entry = Object.entries(pipelineState.agents || {}).find(([, a]) => a.status === 'running');
    if (entry) selectAgent(entry[0]);
  }
}

// ── Initialise ────────────────────────────────────────────────────────────────

buildEdges();
buildNodes();
dpRefs      = buildDetailPanel();
summaryRefs = buildSummaryBar();

// Scale canvas to fit the wrapper — called on init and every resize
function fitCanvas() {
  const wrapper = document.getElementById('canvas-wrapper');
  const canvas  = document.getElementById('canvas');
  if (!wrapper || !canvas) return;
  const scale = Math.min(wrapper.clientWidth / 1500, wrapper.clientHeight / 620);
  canvas.style.transform = `scale(${scale})`;
}
fitCanvas();
window.addEventListener('resize', fitCanvas);

// Tick elapsed timer every second
setInterval(() => {
  if (pipelineState && summaryRefs) renderSummaryBar(pipelineState);
}, 1000);

// SSE connection
const es = new EventSource('/events');
es.onmessage = function (e) {
  try { onUpdate(JSON.parse(e.data)); } catch (err) { console.error('SSE parse error', err); }
};
es.onerror = function () {
  if (!pipelineState) {
    setText(document.getElementById('goal-text'), 'Connecting to monitor...');
  }
};
</script>
</body>
</html>
